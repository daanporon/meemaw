// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
)

const addDevice = `-- name: AddDevice :one
INSERT INTO devices (user_id, wallet_id, user_agent, peer_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
RETURNING id, user_id, wallet_id, peer_id, user_agent
`

type AddDeviceParams struct {
	UserId    int64
	WalletId  int64
	UserAgent string
	PeerId    string
}

func (q *Queries) AddDevice(ctx context.Context, arg AddDeviceParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, addDevice,
		arg.UserId,
		arg.WalletId,
		arg.UserAgent,
		arg.PeerId,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.PeerID,
		&i.UserAgent,
	)
	return i, err
}

const addPeer = `-- name: AddPeer :one
WITH existing_user AS (
    SELECT id AS user_id
    FROM users
    WHERE foreign_key = $3
),
updated_wallet AS (
    UPDATE wallets
    SET encrypted_dkg_results = $4,
        nonce = $5
    FROM existing_user
    WHERE wallets.user_id = existing_user.user_id
    RETURNING wallets.id AS wallet_id, wallets.user_id
)
INSERT INTO devices (user_id, wallet_id, user_agent, peer_id)
SELECT user_id, wallet_id, $1, $2
FROM updated_wallet
RETURNING id, user_id, wallet_id, peer_id, user_agent
`

type AddPeerParams struct {
	UserAgent           string
	PeerId              string
	ForeignKey          string
	EncryptedDkgResults []byte
	Nonce               []byte
}

func (q *Queries) AddPeer(ctx context.Context, arg AddPeerParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, addPeer,
		arg.UserAgent,
		arg.PeerId,
		arg.ForeignKey,
		arg.EncryptedDkgResults,
		arg.Nonce,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.PeerID,
		&i.UserAgent,
	)
	return i, err
}

const addUser = `-- name: AddUser :one

INSERT INTO users (foreign_key)
VALUES ($1)
ON CONFLICT DO NOTHING
RETURNING id, foreign_key
`

// ----- INSERTS -------
func (q *Queries) AddUser(ctx context.Context, foreignKey string) (User, error) {
	row := q.db.QueryRowContext(ctx, addUser, foreignKey)
	var i User
	err := row.Scan(&i.ID, &i.ForeignKey)
	return i, err
}

const addWallet = `-- name: AddWallet :one
INSERT INTO wallets (user_id, public_address, encrypted_dkg_results, nonce)
VALUES ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
RETURNING id, user_id, public_address, encrypted_dkg_results, nonce
`

type AddWalletParams struct {
	UserId              int64
	PublicAddress       string
	EncryptedDkgResults []byte
	Nonce               []byte
}

func (q *Queries) AddWallet(ctx context.Context, arg AddWalletParams) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, addWallet,
		arg.UserId,
		arg.PublicAddress,
		arg.EncryptedDkgResults,
		arg.Nonce,
	)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicAddress,
		&i.EncryptedDkgResults,
		&i.Nonce,
	)
	return i, err
}

const dkg = `-- name: Dkg :one
WITH new_user AS (
    INSERT INTO users (foreign_key)
    VALUES ($3)
    ON CONFLICT DO NOTHING
    RETURNING id AS user_id
),
new_wallet AS (
    INSERT INTO wallets (user_id, public_address, encrypted_dkg_results, nonce)
    SELECT user_id, $4, $5, $6
    FROM new_user
    ON CONFLICT DO NOTHING
    RETURNING id AS wallet_id, user_id
)
INSERT INTO devices (user_id, wallet_id, user_agent, peer_id)
SELECT user_id, wallet_id, $1, $2
FROM new_wallet
ON CONFLICT DO NOTHING
RETURNING id, user_id, wallet_id, peer_id, user_agent
`

type DkgParams struct {
	UserAgent           string
	PeerId              string
	ForeignKey          string
	PublicAddress       string
	EncryptedDkgResults []byte
	Nonce               []byte
}

func (q *Queries) Dkg(ctx context.Context, arg DkgParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, dkg,
		arg.UserAgent,
		arg.PeerId,
		arg.ForeignKey,
		arg.PublicAddress,
		arg.EncryptedDkgResults,
		arg.Nonce,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletID,
		&i.PeerID,
		&i.UserAgent,
	)
	return i, err
}

const getFirstUser = `-- name: GetFirstUser :one

SELECT id, foreign_key FROM users
LIMIT 1
`

// ----- SELECTS -------
func (q *Queries) GetFirstUser(ctx context.Context) (User, error) {
	row := q.db.QueryRowContext(ctx, getFirstUser)
	var i User
	err := row.Scan(&i.ID, &i.ForeignKey)
	return i, err
}

const getUserByAddress = `-- name: GetUserByAddress :one
SELECT users.id, users.foreign_key 
FROM wallets
INNER JOIN users ON wallets.user_id = users.id
WHERE wallets.public_address = $1
`

func (q *Queries) GetUserByAddress(ctx context.Context, publicaddress string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByAddress, publicaddress)
	var i User
	err := row.Scan(&i.ID, &i.ForeignKey)
	return i, err
}

const getUserByForeignKey = `-- name: GetUserByForeignKey :one
SELECT id, foreign_key FROM users
WHERE foreign_key = $1
LIMIT 1
`

func (q *Queries) GetUserByForeignKey(ctx context.Context, foreignkey string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByForeignKey, foreignkey)
	var i User
	err := row.Scan(&i.ID, &i.ForeignKey)
	return i, err
}

const getUserDevices = `-- name: GetUserDevices :many
SELECT id, user_id, wallet_id, peer_id, user_agent FROM devices
WHERE user_id = $1
`

func (q *Queries) GetUserDevices(ctx context.Context, userid int64) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, getUserDevices, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletID,
			&i.PeerID,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSigningParameters = `-- name: GetUserSigningParameters :one
SELECT wallets.id, wallets.user_id, wallets.public_address, wallets.encrypted_dkg_results, wallets.nonce
FROM users
LEFT JOIN wallets ON users.id = wallets.user_id
WHERE users.foreign_key = $1
`

type GetUserSigningParametersRow struct {
	ID                  sql.NullInt64
	UserID              sql.NullInt64
	PublicAddress       sql.NullString
	EncryptedDkgResults []byte
	Nonce               []byte
}

func (q *Queries) GetUserSigningParameters(ctx context.Context, foreignkey string) (GetUserSigningParametersRow, error) {
	row := q.db.QueryRowContext(ctx, getUserSigningParameters, foreignkey)
	var i GetUserSigningParametersRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicAddress,
		&i.EncryptedDkgResults,
		&i.Nonce,
	)
	return i, err
}

const getUserWallets = `-- name: GetUserWallets :many
SELECT id, user_id, public_address, encrypted_dkg_results, nonce FROM wallets
WHERE user_id = $1
`

func (q *Queries) GetUserWallets(ctx context.Context, userid int64) ([]Wallet, error) {
	rows, err := q.db.QueryContext(ctx, getUserWallets, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PublicAddress,
			&i.EncryptedDkgResults,
			&i.Nonce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletByAddress = `-- name: GetWalletByAddress :one
SELECT id, user_id, public_address, encrypted_dkg_results, nonce FROM wallets
WHERE public_address = $1
`

func (q *Queries) GetWalletByAddress(ctx context.Context, publicaddress string) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWalletByAddress, publicaddress)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PublicAddress,
		&i.EncryptedDkgResults,
		&i.Nonce,
	)
	return i, err
}

const status = `-- name: Status :one
SELECT 1
`

func (q *Queries) Status(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, status)
	var column_1 interface{}
	err := row.Scan(&column_1)
	return column_1, err
}
